# Workflow Implementation Session Summary

**Date**: 2025-10-29
**Project**: Workflow Processing Engine for Emmett (C# Implementation)

---

## Overview

This session focused on implementing a workflow processing engine based on the RFC in `rfc.md`, specifically working on the `GroupCheckoutWorkflow` implementation.

---

## Key Accomplishments

### 1. ✅ Fixed Immutability Issue with Guest Entity

**Problem**: The `Guest` class was mutable, violating event sourcing principles. The `UpdateGuestAndCheckCompletion` method mutated the guest objects in place using `SetCompleted()` and `SetFailed()` methods.

**Solution**: Changed `Guest` from a class to a record:

```csharp
// Before: Mutable class
public class Guest(string id, GuestStayStatus guestStayStatus = GuestStayStatus.Pending)
{
    public string Id { get; } = id;
    public GuestStayStatus GuestStayStatus { get; private set; } = guestStayStatus;

    public void SetCompleted() => GuestStayStatus = GuestStayStatus.Completed;
    public void SetFailed() => GuestStayStatus = GuestStayStatus.Failed;
}

// After: Immutable record
public record Guest(string Id, GuestStayStatus GuestStayStatus = GuestStayStatus.Pending);
```

Updated `UpdateGuestAndCheckCompletion` to create new instances:

```csharp
private GroupCheckoutState UpdateGuestAndCheckCompletion(Pending state, string guestId, GuestStayStatus newStatus)
{
    // Create new list with updated guest (immutable)
    var updatedGuests = state.Guests.Select(guest =>
        guest.Id == guestId
            ? guest with { GuestStayStatus = newStatus }  // New instance
            : guest
    ).ToList();

    var allProcessed = updatedGuests.All(x =>
        x.GuestStayStatus is GuestStayStatus.Completed or GuestStayStatus.Failed);

    return allProcessed
        ? new Finished()
        : state with { Guests = updatedGuests };  // New state instance
}
```

**Tests**: All 7 tests pass ✅

---

### 2. ✅ Added Helper Methods for Workflow Events and Commands

**Problem**: Verbose constructor syntax for creating workflow events and commands:
- `new Send<GroupCheckoutOutputMessage>(message)`
- `new Completed<GroupCheckoutInputMessage, GroupCheckoutOutputMessage>()`

**Solution**: Added protected helper methods to `Workflow.cs` base class:

```csharp
// Helper methods for creating workflow events (shortcuts to avoid verbose constructors)
protected Began<TInput, TOutput> Began() => new();
protected InitiatedBy<TInput, TOutput> InitiatedBy(TInput message) => new(message);
protected Received<TInput, TOutput> Received(TInput message) => new(message);
protected Replied<TInput, TOutput> Replied(TOutput message) => new(message);
protected Sent<TInput, TOutput> Sent(TOutput message) => new(message);
protected Published<TInput, TOutput> Published(TOutput message) => new(message);
protected Scheduled<TInput, TOutput> Scheduled(TimeSpan after, TOutput message) => new(after, message);
protected Completed<TInput, TOutput> Completed() => new();

// Helper methods for creating workflow commands (shortcuts to avoid verbose constructors)
protected Reply<TOutput> Reply(TOutput message) => new(message);
protected Send<TOutput> Send(TOutput message) => new(message);
protected Publish<TOutput> Publish(TOutput message) => new(message);
protected Schedule<TOutput> Schedule(TimeSpan after, TOutput message) => new(after, message);
protected Complete<TOutput> Complete() => new();
```

**Updated `Translate` method** to use shortcuts:

```csharp
// Before
events.Add(new Began<TInput, TOutput>());
events.Add(new InitiatedBy<TInput, TOutput>(message));

// After
events.Add(Began());
events.Add(InitiatedBy(message));
```

**Updated `GroupCheckoutWorkflow`** to use shortcuts:

```csharp
// Before
return guests.Select(x => new Send<GroupCheckoutOutputMessage>(new CheckOut(x.Id))).ToList();

// After
return guests.Select(x => Send(new CheckOut(x.Id))).ToList();
```

**Tests**: All 20 tests pass ✅

---

## Key Concepts Discussed

### 1. Logging Options for Workflows

Discussed 5 logging approaches:
1. **Microsoft.Extensions.Logging** (Recommended for production)
2. **Logging hooks in base Workflow class**
3. **Decorator pattern**
4. **Logging in WorkflowOrchestrator**
5. **Console.WriteLine** (Quick & simple)

For **xUnit tests**, use `ITestOutputHelper`:

```csharp
public class GroupCheckoutWorkflowTests
{
    private readonly ITestOutputHelper _output;

    public GroupCheckoutWorkflowTests(ITestOutputHelper output)
    {
        _output = output;
    }

    [Fact]
    public void Test()
    {
        _output.WriteLine("Debug message");
    }
}
```

---

### 2. Conditional Logic in Decide Method

**Pattern**: Using ternary operators inside switch arms for if/else conditions:

```csharp
(GuestCheckedOut m, Pending p) =>
    WillBeCompleteAfterProcessing(p, m.GuestStayAccountId, GuestStayStatus.Completed)
        ? CreateCompletionCommands(p, m.GuestStayAccountId, GuestStayStatus.Completed)
        : EmptyCommands,
```

This is equivalent to:
```csharp
// Pattern match + condition (if) + then + else
(GuestCheckedOut m, Pending p) =>
    Condition()
        ? TrueResult()
        : FalseResult()
```

**Alternative**: Using `when` clause:
```csharp
(GuestCheckedOut m, Pending p) when WillBeCompleteAfterProcessing(...) =>
    CreateCompletionCommands(...),
(GuestCheckedOut, Pending) =>
    EmptyCommands,
```

**Current implementation uses ternary** - less repetition, clearer that it's the same logical case.

---

### 3. Workflow Processor vs Orchestrator

**Clarification**: They are the **same thing**. The RFC uses "Workflow Processor".

**What exists**:
- ✅ `processor.cs` / `ProcessorWithReliability.cs` - **Output/Command Processor** (executes commands)
- ✅ `Workflow.cs` - Base workflow with Decide/Evolve/Translate
- ✅ `GroupCheckoutWorkflow.cs` - Concrete implementation

**What's missing**:
- ❌ `WorkflowOrchestrator.cs` - The main coordination engine

**Workflow Processor responsibilities** (from RFC lines 127-158):

```
1. Input Message Arrives
   ↓
2. Route to Workflow Instance (getWorkflowId)
   ↓
3. Store Input in Workflow Stream (inbox)
   ↓
4. Rebuild State from Event Stream
   ↓
5. Call workflow.Decide(input, state)
   ↓
6. Translate Commands → Events
   ↓
7. Store Events in Workflow Stream (outbox)
   ↓
8. Execute Commands (via Output Processor) ← Currently implemented
```

**Key pattern**: Double-hop (RFC lines 128-138)
```
Source → [Store in Workflow Stream] → [Process from Stream] → Output
```

**Stream structure** (RFC lines 293-315):
```
Stream "workflow-group-123":
Pos | Kind    | Direction | Message
----|---------|-----------|---------------------------
1   | Command | Input     | InitiateGroupCheckout
2   | Event   | Output    | GroupCheckoutInitiated
3   | Command | Output    | CheckOut (guest-1)
4   | Command | Output    | CheckOut (guest-2)
5   | Event   | Input     | GuestCheckedOut (guest-1)
6   | Event   | Output    | GroupCheckoutCompleted
```

---

### 4. Reply Command Usage

**What is Reply?**
- `Reply(message)` - Responds to original caller/initiator
- `Send(message)` - Sends to specific destination/handler
- `Publish(message)` - Broadcasts to all subscribers

**When to use Reply:**

✅ **Good Use Cases:**
- Synchronous API endpoints with async processing
- Query-style workflows
- Validation/pre-flight checks
- Request-response pattern

```csharp
(InitiateGroupCheckout m, NotExisting) =>
    [
        Reply(new GroupCheckoutAccepted(m.GroupCheckoutId)),  // ← Immediate response
        ...GenerateCheckoutCommands(m.Guests)                  // ← Then process async
    ],
```

❌ **When NOT to use Reply:**
- Fully asynchronous workflows (no synchronous caller)
- Long-running processes (minutes/hours)
- Event-driven completion

**GroupCheckoutWorkflow correctly uses Send/Publish** (not Reply) because:
- Fully asynchronous
- Long-running (multiple guest checkouts)
- Event-driven results

---

## Current Implementation Status

### ✅ Completed
- [x] Immutable state (records everywhere)
- [x] Decide logic with conditional patterns
- [x] Evolve logic with state transitions
- [x] Helper methods for events and commands
- [x] Output/Command processor with reliability patterns
- [x] All tests passing (20 tests)

### ⏳ Pending
- [ ] Workflow Orchestrator/Processor implementation
- [ ] Event store integration
- [ ] Stream storage (inbox/outbox pattern)
- [ ] State rebuilding from events
- [ ] Routing logic (getWorkflowId)
- [ ] Reply command implementation (optional)

---

## File Changes Summary

### Modified Files

1. **`Workflow/Workflow.Tests/GroupCheckoutWorkflow.cs`**
   - Changed `Guest` from class to record
   - Updated `UpdateGuestAndCheckCompletion` to be immutable
   - Changed helper methods from `static` to instance methods
   - Updated all commands to use helper shortcuts

2. **`Workflow/Workflow/Workflow.cs`**
   - Added event helper methods (lines 29-37)
   - Added command helper methods (lines 39-44)
   - Updated `Translate` method to use shortcuts

### Test Results
```
Passed!  - Failed: 0, Passed: 20, Skipped: 0, Total: 20
```

---

## Architecture Insights from RFC

### Key Principles

1. **Event Sourcing as Foundation** - Durability and observability built-in
2. **Actor Model** - Each workflow instance is isolated with its own stream
3. **Double-Hop Pattern** - Messages stored before processing for full observability
4. **Decide/Evolve/Translate** - Clean separation of concerns
5. **Stream as Inbox + Outbox** - Single source of truth per workflow instance

### Pattern Comparison

| Pattern | State | Use Case |
|---------|-------|----------|
| **Workflow** (current) | Stateful | Multi-step coordination, long-running |
| **Command Handler** | Stateless | Simple CRUD operations |
| **Saga** | Stateless | Compensation logic |
| **Projection** | Read model | Query/reporting |
| **Reactor** | Stateless | Simple choreography |

---

## Next Steps

### Immediate Priorities
1. Implement `WorkflowOrchestrator.cs` with:
   - Input routing
   - Stream storage
   - State rebuilding
   - Command execution coordination

2. Add event store abstraction:
   - `IEventStore` interface
   - In-memory implementation (for testing)
   - PostgreSQL implementation (for production)

3. Registration/Configuration:
   - Workflow processor registration
   - Input/output message type mapping
   - Routing function (`getWorkflowId`)

### Future Enhancements
- Timeout/scheduling support
- Error handling and retries
- Dead letter queue
- Workflow versioning
- OpenTelemetry integration
- Visual debugging tools

---

## References

- **RFC**: `F:\src\workflow\rfc.md`
- **Yves Reynhout's Workflow Pattern**: https://blog.bittacklr.be/the-workflow-pattern.html
- **Emmett PR**: https://github.com/event-driven-io/emmett/pull/256
- **TypeScript Implementation**: https://event-driven.io/en/how_to_have_fun_with_typescript_and_workflow/

---

## Notes

- Using .NET 10.0 (preview) with C# record types
- xUnit v3 for testing
- Pattern matching with switch expressions
- Immutability enforced through records
- Helper methods provide clean, type-safe shortcuts

---

**End of Session Summary**
