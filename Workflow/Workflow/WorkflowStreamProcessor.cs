namespace Workflow;

/// <summary>
/// Processes workflow messages with full persistence using the unified stream approach (RFC Pattern).
///
/// Architecture:
/// 1. Store input message in workflow stream
/// 2. Rebuild state from all events in stream
/// 3. Call Decide to get commands
/// 4. Call Translate to get audit events
/// 5. Store output commands and events in stream
/// 6. Return result
///
/// This class adds persistence to the pure WorkflowOrchestrator logic.
/// The workflow stream serves as both inbox (inputs) and outbox (outputs).
/// </summary>
public class WorkflowStreamProcessor<TInput, TState, TOutput>(
    WorkflowOrchestrator<TInput, TState, TOutput> orchestrator,
    IWorkflowPersistence<TInput, TState, TOutput> persistence)
{
    /// <summary>
    /// Processes a message with full persistence and stream-based durability.
    ///
    /// RFC Flow (lines 131-138):
    /// 1. Store input in workflow stream
    /// 2. Rebuild state from stream
    /// 3. Call decide
    /// 4. Store outputs in stream
    /// 5. Return result
    ///
    /// The processor automatically determines if this is the beginning of the workflow
    /// by checking if there are any events in the event history.
    /// </summary>
    public async Task<StreamProcessingResult<TInput, TState, TOutput>> ProcessAsync(
        IWorkflow<TInput, TState, TOutput> workflow,
        string workflowId,
        TInput message)
    {
        // Step 1: Store input message in stream
        var inputMessage = new WorkflowMessage<TInput, TOutput>(
            WorkflowId: workflowId,
            Position: 0, // Will be assigned by persistence
            Kind: DetermineMessageKind(message),
            Direction: MessageDirection.Input,
            Message: message!,
            Timestamp: DateTime.UtcNow,
            Processed: null // Only commands need processing tracking
        );

        await persistence.AppendAsync(workflowId, [inputMessage]);

        // Step 2: Rebuild state by replaying all events from the stream
        var allMessages = await persistence.ReadStreamAsync(workflowId);
        var snapshot = RebuildStateFromStream(workflow, allMessages);

        // Step 3: Automatically determine if this is the beginning
        // If there are no events in history, this is the first message
        var begins = !snapshot.EventHistory.Any();

        // Step 4 & 5: Use pure orchestrator for business logic (Decide + Translate)
        var orchestrationResult = orchestrator.Process(workflow, snapshot, message, begins);

        // Step 5: Convert commands to output messages
        var currentPosition = allMessages.Any() ? allMessages.Max(m => m.Position) : 0;
        var outputMessages = new List<WorkflowMessage<TInput, TOutput>>();

        foreach (var command in orchestrationResult.Commands)
        {
            // Skip Complete - it's a meta-command, not a message to store
            if (command is Complete<TOutput>)
                continue;

            currentPosition++;

            // Extract the actual output message from the command
            var outputMessage = ExtractOutputFromCommand(command);

            outputMessages.Add(new WorkflowMessage<TInput, TOutput>(
                WorkflowId: workflowId,
                Position: currentPosition,
                Kind: MessageKind.Command,
                Direction: MessageDirection.Output,
                Message: outputMessage,
                Timestamp: DateTime.UtcNow,
                Processed: false // Needs to be executed by output processor
            ));
        }

        // Step 6: Convert events to output messages (for audit trail)
        foreach (var evt in orchestrationResult.Events)
        {
            currentPosition++;

            outputMessages.Add(new WorkflowMessage<TInput, TOutput>(
                WorkflowId: workflowId,
                Position: currentPosition,
                Kind: MessageKind.Event,
                Direction: MessageDirection.Output,
                Message: evt!,
                Timestamp: DateTime.UtcNow,
                Processed: null // Events don't need processing
            ));
        }

        // Step 7: Persist all output messages atomically
        if (outputMessages.Any())
        {
            await persistence.AppendAsync(workflowId, outputMessages);
        }

        // Step 8: Return result with updated snapshot
        return new StreamProcessingResult<TInput, TState, TOutput>(
            WorkflowId: workflowId,
            Snapshot: orchestrationResult.Snapshot,
            OutputMessages: outputMessages,
            StreamPosition: currentPosition
        );
    }

    /// <summary>
    /// Rebuilds workflow state by replaying all events through Evolve.
    /// Only output events (Direction=Output, Kind=Event) are used for state evolution.
    /// These are the events generated by Translate which are WorkflowEvent instances.
    /// Input messages are stored for audit but not used for state evolution.
    /// </summary>
    private WorkflowSnapshot<TInput, TState, TOutput> RebuildStateFromStream(
        IWorkflow<TInput, TState, TOutput> workflow,
        IReadOnlyList<WorkflowMessage<TInput, TOutput>> messages)
    {
        var events = messages
            .Where(m => m.IsEventForStateEvolution && m.Direction == MessageDirection.Output)
            .Select(m => (WorkflowEvent<TInput, TOutput>)m.Message)
            .ToList();

        var state = workflow.InitialState;
        foreach (var evt in events)
        {
            state = workflow.Evolve(state, evt);
        }

        return new WorkflowSnapshot<TInput, TState, TOutput>(
            State: state,
            EventHistory: events
        );
    }

    /// <summary>
    /// Extracts the actual output message from a WorkflowCommand.
    /// Note: Complete commands are filtered out before calling this method.
    /// </summary>
    private TOutput ExtractOutputFromCommand(WorkflowCommand<TOutput> command)
    {
        return command switch
        {
            Send<TOutput> send => send.Message!,
            Publish<TOutput> publish => publish.Message!,
            Reply<TOutput> reply => reply.Message!,
            Schedule<TOutput> schedule => schedule.Message!,
            _ => throw new InvalidOperationException($"Unknown command type: {command.GetType().Name}")
        };
    }

    /// <summary>
    /// Determines if a message is a command or event.
    /// This is a heuristic - in production you'd use naming conventions or interfaces.
    /// </summary>
    private MessageKind DetermineMessageKind(TInput message)
    {
        // Heuristic: Messages ending with "Command" or verbs are commands
        // Messages ending with past tense (ed) are events
        var typeName = message!.GetType().Name;

        if (typeName.EndsWith("Command", StringComparison.OrdinalIgnoreCase))
            return MessageKind.Command;

        // Default to event (most input messages are events)
        return MessageKind.Event;
    }
}

/// <summary>
/// Result of stream-based workflow processing with persistence.
/// </summary>
public record StreamProcessingResult<TInput, TState, TOutput>(
    string WorkflowId,
    WorkflowSnapshot<TInput, TState, TOutput> Snapshot,
    IReadOnlyList<WorkflowMessage<TInput, TOutput>> OutputMessages,
    long StreamPosition
);
